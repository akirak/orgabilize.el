{"html-title":"<h1>A Complete Guide to Custom Properties | CSS-Tricks</h1>","title":"A Complete Guide to Custom Properties | CSS-Tricks","excerpt":"Everything important and useful to know about CSS Custom Properties. Like that they are often referred to as \"CSS Variables\" but that's not their real name.","byline":"Tyler Childs","length":25492,"dir":null,"text-content":"\n\n\n\n\n\n\nA custom property is most commonly thought of as a variable in CSS.\n.card {\n  --spacing: 1.2rem;\n  padding: var(--spacing);\n  margin-bottom: var(--spacing);\n}\nAbove, --spacing is the custom property with 1.2rem as the value and var(--spacing) is the variable in use. \nPerhaps the most valuable reason to use them: not repeating yourself (DRY code). In the example above, I can change the value 1.2rem in one place and have it affect two things. This brings something programming languages do to CSS.\nThere is a good bit to know about custom properties, so let’s get into it. \n\n\nWhy care about CSS Custom Properties?\nThey help DRY up your CSS. That is “Don’t Repeat Yourself.” Custom properties can make code easier to maintain because you can update one value and have it reflected in multiple places. Careful though, overdoing abstraction can make have the opposite effect and make code less understandable.They are particularly helpful for things like creating color themes on a website.They unlock interesting possibilities in CSS. In no small part because they cascade.The fact that they can be updated in JavaScript opens up even more interesting possibilities.\n\n\n\n\n\nTable of contents\n\nWhy care about CSS Custom Properties?Naming custom propertiesProperties as propertiesValid values for custom propertiesBreaking up valuesSplitting colorsShadowsGradientsComma-separated values (like backgrounds)GridsTransformsConcatenation of unit typesUsing the cascadeThe :root thingCombining with !importantCustom property fallbacksUsing calc() and custom propertiesDeferring the calc()@propertyCommas in valuesAdvanced usageThe initial and whitespace trickInline stylesHovers and pseudosCustom properties and JavaScriptCustom properties are different than preprocessor variablesCan you preprocess custom properties?AvailiabilityCustom properties and Web Components (Shadow DOM)Browser support@supportsRelated postsCredit\n\n\n\nNaming custom properties\n\n\nCustom properties must be within a selector and start with two dashes (--):\n/* Nope, not within a selector */\n--foo: 1;\n\nbody {\n  /* No, 0 or 1 dash won't work */\n  foo: 1;\n  -foo: 1; \n\n  /* Yep! */\n  --foo: 1;\n\n  /* OK, but they're different properties */\n  --FOO: 1;\n  --Foo: 1;\n  \n  /* Totally fine */\n  --mainColor: red;\n  --main-color: red;\n\n  /* Special characters are a no */\n  [email protected]: red;\n  --black&blue: black;\n  --black^2: black;\n}\nBest to stick with letters, numbers, and dashes while making sure the custom property is defined inside of a valid selector.\n\n\nProperties as properties\nYou can set the value of a custom property with another custom property:\nhtml {\n  --red: #a24e34;\n  --green: #01f3e6;\n  --yellow: #f0e765;\n\n  --error: var(--red);\n  --errorBorder: 1px dashed var(--red);\n  --ok: var(--green);\n  --warning: var(--yellow);\n}\nSome people like doing it this way because it allows the name of a custom property to be descriptive and then used in another property with a more functional name, again helping keep things DRY. It can even help make the functional names more readable and understandable.\n\n\nValid values for custom properties\n\n\nCustom properties are surprisingly tolerant when it comes to the values they accept. \n\nHere are some basic examples that you’d expect to work, and do.\nbody {\n  --brand-color: #990000;\n  --transparent-black: rgba(0, 0, 0, 0.5);\n  \n  --spacing: 0.66rem;\n  --max-reading-length: 70ch;\n  --brandAngle: 22deg;\n\n  --visibility: hidden;\n  --my-name: \"Chris Coyier\";\n}\nSee that? They can be hex values, color functions, units of all kinds, and even strings of text.\n\nBut custom properties don’t have to be complete values like that. Let’s look at how useful it can be to break up valid CSS values into parts we can shove into custom properties.\nBreaking up values\n\n\nYou can use custom properties to break up multi-part values.\n\nLet’s imagine you’re using a color function, say rgba(). Each color channel value in there can be its own custom property. That opens up a ton of possibilities, like changing the alpha value for a specific use case, or perhaps creating color themes.\nSplitting colors\nTake HSL color, for example. We can split it up into parts, then very easily adjust the parts where we want. Maybe we’re working with the background color of a button. We can update specific parts of its HSL makeup when the button is hovered, in focus, or disabled, without declaring background on any of those states at all.\nbutton {\n  --h: 100;\n  --s: 50%;\n  --l: 50%;\n  --a: 1;\n\n  background: hsl(var(--h) var(--s) var(--l) / var(--a));\n}\nbutton:hover { /* Change the lightness on hover */\n  --l: 75%;\n}\nbutton:focus { /* Change the saturation on focus */\n  --s: 75%;\n}\nbutton[disabled] {  /* Make look disabled */\n  --s: 0%;\n  --a: 0.5;\n}\nBy breaking apart values like that, we can control parts of them in a way we never could before. Just look at how we didn’t need to declare all of the HSL arguments to style the hover, focus and disabled state of a button. We simply overrode specific HSL values when we needed to. Pretty cool stuff!\n\n\nShadows\nbox-shadow doesn’t have a shorthand property for controlling the shadow’s spread on its own. But we could break out the box-shadow spread value and control it as a custom property (demo).\nbutton {\n  --spread: 5px;\n  box-shadow: 0 0 20px var(--spread) black;\n}\nbutton:hover {\n  --spread: 10px;\n}\n\n\nGradients\nThere is no such thing as a background-gradient-angle (or the like) shorthand for gradients. With custom properties, we can change just change that part as if there was such a thing.\nbody {\n  --angle: 180deg;\n  background: linear-gradient(var(--angle), red, blue);\n}\nbody.sideways {\n  --angle: 90deg;\n}\n\n\nComma-separated values (like backgrounds)\nAny property that supports multiple comma-separated values might be a good candidate for splitting values too, since there is no such thing as targeting just one value of a comma-separated list and changing it alone.\n/* Lots of backgrounds! */\nbackground-image:\n  url(./img/angles-top-left.svg),\n  url(./img/angles-top-right.svg),\n  url(./img/angles-bottom-right.svg),\n  url(./img/angles-bottom-left.svg),\n  url(./img/bonus-background.svg);\nSay you wanted to remove just one of many multiple backgrounds at a media query. You could do that with custom properties like this, making it a trivial task to swap or override backgrounds.\nbody {\n  --bg1: url(./img/angles-top-left.svg);\n  --bg2: url(./img/angles-top-right.svg);\n  --bg3: url(./img/angles-bottom-right.svg);\n  --bg4: url(./img/angles-bottom-left.svg);\n  --bg5: url(./img/bonus-background.svg);\n  \n  background-image: var(--bg1), var(--bg2), var(--bg3), var(--bg4);\n}\n@media (min-width: 1500px) {\n  body {\n    background-image: var(--bg1), var(--bg2), var(--bg3), var(--bg4), var(--bg5);\n  }\n}\n\n\nGrids\nWe’re on a roll here, so we might as well do a few more examples. Like, hey, we can take the grid-template-columns property and abstract its values into custom properties to make a super flexible grid system:\n.grid {\n  display: grid;\n  --edge: 10px;\n  grid-template-columns: var(--edge) 1fr var(--edge);\n}\n@media (min-width: 1000px) {\n  .grid {\n     --edge: 15%;\n   }\n}\n\n\nTransforms\nCSS will soon get individual transforms but we can get it sooner with custom properties. The idea is to apply all the transforms an element might get up front, then control them individually as needed:\nbutton {\n  transform: var(--scale, scale(1)) var(--translate, translate(0));\n}\nbutton:active {\n  --translate: translate(0, 2px);\n}\nbutton:hover {\n  --scale: scale(0.9);\n}\n\n\nConcatenation of unit types\nThere are times when combining parts of values doesn’t work quite how you might hope. For example, you can’t make 24px by smashing 24 and px together. It can be done though, by multiplying the raw number by a number value with a unit.\nbody {\n  --value: 24;\n  --unit: px;\n  \n  /* Nope */\n  font-size: var(--value) + var(--unit);\n  \n  /* Yep */\n  font-size: calc(var(--value) * 1px);\n\n  /* Yep */\n  --pixel_converter: 1px;\n  font-size: calc(var(--value) * var(--pixel_converter));\n}\n\nUsing the cascade\n\n\nThe fact that custom properties use the cascade is one of the most useful things about them. \n\nYou’ve already seen it in action in many of the examples we’ve covered, but let’s put a point on it. Say we have a custom property set pretty “high up” (on the body), and then set again on a specific class. We use it on a specific component.\nbody {\n  --background: white;\n}\n.sidebar {\n  --background: gray;\n}\n.module {\n  background: var(--background);\n}\nThen say we’ve got practical HTML like this:\n\n\n<body> <!-- --background: white -->\n\n  <main>\n    <div class=\"module\">\n      I will have a white background.\n    </div>\n  <main>\n\n  <aside class=\"sidebar\"> <!-- --background: gray -->\n    <div class=\"module\">\n      I will have a gray background.\n    </div>\n  </aside>\n\n</body>\n\nFor the second module, .sidebar is a closer ancestor than body, thus --background resolves to gray there, but white in other places.\n\nThe “module” in the sidebar has a gray background because custom properties (like many other CSS properties) inherit through the HTML structure. Each module takes the --background value from the nearest “ancestor” where it’s been defined in CSS.\nSo, we have one CSS declaration but it’s doing different things in different contexts, thanks to the cascade. That’s just cool. \nThis plays out in other ways:\nbutton {\n  --foo: Default;\n}\nbutton:hover {\n  --foo: I win, when hovered;\n  /* This is a more specific selector, so re-setting \n     custom properties here will override those in `button` */\n}\nMedia queries don’t change specificity, but they often come later (or lower) in the CSS file than where the original selector sets a value, which also means a custom property will be overridden inside the media query:\nbody {\n  --size: 16px;\n  font-size: var(--size);\n}\n@media (max-width: 600px) {\n  body {\n    --size: 14px;\n  } \n}\nMedia queries aren’t only for screen sizes. They can be used for things like accessibility preferences. For example, dark mode:\nbody {\n  --bg-color: white; \n  --text-color: black;\n\n  background-color: var(--bg-color);\n  color: var(--text-color);\n}\n\n/* If the user's preferred color scheme is dark */\n@media screen and (prefers-color-scheme: dark) {\n  body {\n    --bg-color: black;\n    --text-color: white;\n  }\n}\nThe :root thing\nYou’ll often see custom properties being set “at the root.” Here’s what that means:\n:root {\n  --color: red;\n}\n\n/* ...is largely the same as writing: */\nhtml {\n  --color: red;\n}\n\n/* ...except :root has higher specificity, so remember that! */\nThere is no particularly compelling reason to define custom properties like that. It’s just a way of setting custom properties as high up as they can go. If you like that, that’s totally fine. I find it somehow more normal-feeling to apply them to the html or body selectors when setting properties I intend to make available globally, or everywhere.\nThere is also no reason you need to set variables at this broad of a scope. It can be just as useful, and perhaps more readable and understandable, to set them right at the level you are going to use them (or fairly close in the DOM tree).\n.module {\n  --module-spacing: 1rem;\n  --module-border-width: 2px;\n\n  border: var(--module-border-width) solid black;\n}\n\n.module + .module {\n  margin-top: var(--module-spacing);\n}\nNote that setting a custom property on the module itself means that property will no longer inherit from an ancestor (unless we set the value to inherit). Like other inherited properties, there are sometimes reasons to specify them in place (at the global level), and other times we want to inherit them from context (at the component level). Both are useful. What’s cool about custom properties is that we can define them in one place, inherit them behind the scenes and apply them somewhere completely different. We take control of the cascade!\n\nCombining with !important\n\n\nYou can make an !important modifier within or outside of a variable.\n\n.override-red {\n  /* this works */\n  --color: red !important;  \n  color: var(--color);\n\n  /* this works, too */\n  --border: red;\n  border: 1px solid var(--border) !important;\n}\nApplying !important to the --color variable, makes it difficult to override the value of the --color variable, but we can still ignore it by changing the color property. In the second example, our --border variable remains low-specificity (easy to override), but it’s hard to change how that value will be applied to the border itself.\nCustom property fallbacks\n\n\nThe var() function is what allows for fallback values in custom properties.\n\nHere we’re setting a scale() transform function to a custom property, but there is a comma-separated second value of 1.2. That 1.2 value will be used if --scale is not set.\n.bigger {\n  transform: scale(var(--scale, 1.2));\n}\nAfter the first comma, any additional commas are part of the fallback value. That allows us to create fallbacks with comma-separated values inside them. For example, we can have one variable fall back to an entire stack of fonts:\nhtml {\n  font-family: var(--fonts, Helvetica, Arial, sans-serif);\n}\nWe can also provide a series of variable fallbacks (as many as we want), but we have to nest them for that to work:\n.bigger {\n  transform: scale(var(--scale, var(--second-fallback, 1.2));\n}\nIf --scale is undefined, we try the --second-fallback. If that is also undefined, we finally fall back to 1.2.\nUsing calc() and custom properties\n\n\nEven more power of custom properties is unlocked when we combine them with math!\n\nThis kind of thing is common:\nmain {\n  --spacing: 2rem;\n}\n\n.module {\n  padding: var(--spacing);\n}\n\n.module.tight {\n  /* divide the amount of spacing in half */\n  padding: calc(var(--spacing) / 2)); \n}\nWe could also use that to calculate the hue of a complementary color:\nhtml {\n  --brand-hue: 320deg;\n  --brand-color: hsl(var(--brand-hue), 50%, 50%);\n  --complement: hsl(calc(var(--brand-hue) + 180deg), 50%, 50%);\n}\ncalc() can even be used with multiple custom properties:\n.slider {\n  width: calc(var(--number-of-boxes) * var(--width-of-box));\n}\nDeferring the calc()\nIt might look weird to see calculous-like math without a calc():\nbody {\n  /* Valid, but the math isn't actually performed just yet ... */\n  --font-size: var(--base-font-size) * var(--modifier);\n\n  /* ... so this isn't going to work */\n  font-size: var(--font-size);\n}\nThe trick is that as long as you eventually put it in a calc() function, it works fine:\nbody {\n  --base-font-size: 16px;\n  --modifier: 2;\n  --font-size: var(--base-font-size) * var(--modifier);\n\n  /* The calc() is \"deferred\" down to here, which works */\n  font-size: calc(var(--font-size));\n}\nThis might be useful if you’re doing quite a bit of math on your variables, and the calc() wrapper becomes distracting or noisy in the code.\n@property\n\n\nThe @property “at-rule” in CSS allows you to declare the type of a custom property, as well its as initial value and whether it inherits or not.\n\nIt’s sort of like you’re creating an actual CSS property and have the ability to define what it’s called, it’s syntax, how it interacts with the cascade, and its initial value.\n@property --x {\n  syntax: '<number>';\n  inherits: false;\n  initial-value: 42;\n}\n\n\nValid Types \nlengthnumberpercentagelength-percentagecolorimageurlintegerangletimeresolutiontransform-listtransform-functioncustom-ident (a custom identifier string)\n\nThis means that the browser knows what kind of value it is dealing with, rather than assuming everything is a string. That means you can animate things in ways you couldn’t otherwise.\nFor example, say you have a star-shaped icon that you want to spin around with @keyframes and rotate with a transform. So you do this:\n.star {\n  --r: 0deg;\n  transform: rotate(var(--r));\n  animation: spin 1s linear infinite;\n}\n\n@keyframes spin {\n  100% {\n    --r: 360deg;\n  }\n}\nThat actually won’t work, as the browser doesn’t know that 0deg and 360deg are valid angle values. You have to define them as an <angle> type with @property for that to work.\n@property --r {\n  syntax: '<angle>';\n  initial-value: 0deg;\n  inherits: false;\n}\n\n.star {\n  --r: 0deg;\n  transform: rotate(var(--r));\n  animation: spin 1s linear infinite;\n}\n\n@keyframes spin {\n  100% {\n    --r: 360deg;\n  }\n}\n\n\nDemo \n\n\n\nCommas in values\nThis can be a smidge confusing. Maybe not so much this:\nhtml {\n  --list: 1, 2, 3;\n}\nBut below, you’ll need a sharp eye to realize the fallback value is actually 1.2, 2. The first comma separates the fallback, but all the rest is part of the value.\nhtml {\n  transform: scale(var(--scale, 1.2, 2));\n}\nLearn more about fallbacks above ⮑\nAdvanced usage\n\n\nThe Raven is a technique that emulates container queries using math and custom properties. Be prepared, this goes from 0-100 in complexity right out of the gate!\n\n\n\nDemo \nResize this demo to see a grid of inline-block elements change number of columns from 4 to 3 to 1.\n\n\nHere’s a few more favorite examples that show off advanced usage of custom properties:\n\nThe initial and whitespace trick\nThink of @media queries and how when one thing changes (e.g. the width of the page) you can control multiple things. That’s kind of the idea with this trick. You change one custom property and control multiple things. \nThe trick is that the value of initial for a custom property will trigger a fallback, while an empty whitespace value will not. For the sake of explanation, it let’s define two globally-scoped custom properties, ON and OFF:\n:root {\n  --ON: initial;\n  --OFF: ;\n}\nSay we have a “dark” variation class which sets a number of different properties. The default is --OFF, but can be flipped to --ON whenever:\n.module {\n  --dark: var(--OFF);\n}\n\n.dark { /* could be a media query or whatever */\n  --dark: var(--ON);\n}\nNow you can use --dark to conditinally set values that apply only when you’ve flipped --dark to --ON. Demo:\n\nLea Verou has a great writeup that covers all of this. \nInline styles\nIt’s totally legit to set a custom property in HTML with an inline style.\n<div style=\"--color: red;\"></div>\nThat will, like any inline style, have a very high level of specificity. \nThis can be super useful for when the HTML might have access to some useful styling information that would be too weird/difficult to put into a static CSS file. A good example of that is maintaining the aspect ratio of an element:\n<div style=\"--aspect-ratio: 16 / 9;\"></div>\nNow I can set up some CSS to make a box of that exact size wherever I need to. The full writeup on that is here, but here’s CSS that uses trickery like the ol’ padded box applied to a pseudo element which pushes the box to the desired size:\n[style*=\"--aspect-ratio\"] > :first-child {\n  width: 100%;\n}\n[style*=\"--aspect-ratio\"] > img {  \n  height: auto;\n} \n@supports (--custom: property) {\n  [style*=\"--aspect-ratio\"] {\n    position: relative;\n  }\n  [style*=\"--aspect-ratio\"]::before {\n    content: \"\";\n    display: block;\n    padding-bottom: calc(100% / (var(--aspect-ratio)));\n  }  \n  [style*=\"--aspect-ratio\"] > :first-child {\n    position: absolute;\n    top: 0;\n    left: 0;\n    height: 100%;\n  }  \n}\nBut hey, these days, we have a native aspect-ratio property in CSS, so setting that in the inline style might make more sense going forward.\n<div style=\"aspect-ratio: 16 / 9;\"></div>\nHovers and pseudos\nThere is no way to apply a :hover style (or other pseudo classes/elements) with inline styles. That is, unless we get tricky with custom properties. Say we want custom hover colors on some boxes — we can pass that information in as a custom property:\n<div style=\"--hover-color: red;\"><div>\n<div style=\"--hover-color: blue;\"><div>\n<div style=\"--hover-color: yellow;\"><div>\nThen use it in CSS which, of course, can style a link’s hover state:\ndiv:hover {\n  background-color: var(--hover-color);\n}\n\n/* And use in other pseudos! */\ndiv:hover::after {\n  content: \"I am \" attr(style);\n  border-color: var(--hover-color);\n}\nCustom properties and JavaScript\n\n\nJavaScript can set the value of a custom property.\n\nelement.style.setProperty('--x', value);\nHere’s an example of a red square that is positioned with custom properties, and JavaScript updates those custom property values with the mouse position:\n\nTypically you think of JavaScript passing values to CSS to use, which is probably 99% of usage here, but note that you can pass things from CSS to JavaScript as well. As we’ve seen, the value of a custom property can be fairly permissive. That means you could pass it a logical statement. For example:\nhtml {\n  --logic: if (x > 5) document.body.style.background = \"blue\";\n}\nThen grab that value and execute it in JavaScript:\nconst x = 10;\n\nconst logic = getComputedStyle(document.documentElement).getPropertyValue(\n  \"--logic\"\n);\n\neval(logic);\nCustom properties are different than preprocessor variables\n\n\nSay you’re already using Sass, Less, or Stylus. All those CSS preprocessors offer variables and it’s one of the main reasons to have them as part of your build process.\n\n// Variable usage in Sass (SCSS)\n$brandColor: red;\n\n.marketing {\n  color: $brandColor;\n}\nSo, do you even need to bother with native CSS custom properties then? Yes, you should. Here’s why in a nutshell:\nNative CSS custom properties are more powerful then preprocessor variables. Their integration with the cascade in the DOM is something that preprocessor variables will never be able to do.Native CSS custom properties are dynamic. When they change (perhaps via JavaScript, or with a media query), the browser repaints what it needs to. Preprocessor variables resolve to a value when they’re compiled and stay at that value.Going with a native feature is good for the longevity of your code. You don’t need to preprocess native CSS.\nI cover this in much more detail in the article “What is the difference between CSS variables and preprocessor variables?”\nTo be totally fair, there are little things that preprocessor variables can do that are hard or impossible with custom properties. Say you wanted to strip the units off a value for example. You can do that in Sass but you’ll have a much harder time with custom properties in CSS alone.\nCan you preprocess custom properties?\nKinda. You can do this, with Sass just to pick one popular preprocessor:\n$brandColor: red;\nbody {\n  --brandColor: $brandColor;\n}\nAll that’s doing is moving a Sass variable to a custom property. That could be useful sometimes, but not terribly. Sass will just make --brandColor: red; there, not process the custom property away. \nIf a browser doesn’t support custom properties, that’s that. You can’t force a browser to do what custom properties do by CSS syntax transformations alone. There might be some kind of JavaScript polyfill that parses your CSS and replicates it, but I really don’t suggest that. \nThe PostCSS Custom Properties plugin, though, does do CSS syntax transforms to help. What it does is figure out the value to the best of it’s ability, and outputs that along with the custom property. So like:\n:root {\n  --brandColor: red;\n}\nbody {\n  color: var(--brandColor);\n}\nWill output like this:\n:root {\n  --brandColor: red;\n}\nbody {\n  color: red;\n  color: var(--brandColor);\n}\nThat means you get a value that hopefully doesn’t seem broken in browsers that lack custom property support, but does not support any of the fancy things you can do with custom properties and will not even attempt to try. I’m a bit dubious about how useful that is, but I think this is about the best you can do and I like the spirit of attempting to not break things in older browsers or newer browsers.\nAvailiability\nAnother thing that is worth noting about the difference between is that with a CSS preprocessor, the variables are available only as you’re processing. Something like $brandColor is meaningless in your HTML or JavaScript. But when you have custom properties in use, you can set inline styles that use those custom properties and they will work. Or you can use JavaScript to figure out their current values (in context), if needed.\nAside from some somewhat esoteric features of preprocessor variables (e.g. some math possibilities), custom properties are more capable and useful. \nCustom properties and Web Components (Shadow DOM)\n\n\nOne of the most common and practical ways to style of Web Components (e.g. a <custom-component> with shadow DOM) is by using custom properties as styling hooks. \n\nThe main point of the shadow DOM is that it doesn’t “leak” styles in or out of it, offering style isolation in a way that nothing else offers, short of an <iframe>. Styles do still cascade their way inside, I just can’t select my way inside. This means custom properties will slide right in there.\nHere’s an example:\n\nAnother common occurrence of the shadow DOM is with SVG and the <use> element. \n\nVideo: “CSS Custom Properties Penetrate the Shadow DOM”\nBrowser support\nDesktopChromeFirefoxIEEdgeSafari4931No1610Mobile / TabletAndroid ChromeAndroid FirefoxAndroidiOS Safari90879010.0-10.2\nYou can preprocess for deeper browser support, with heavy limitations.\n@supports\nIf you would like to write conditional CSS for when a browser supports custom properties or not:\n@supports (--custom: property) {\n  /* Isolated CSS for browsers that DOES support custom properties, assuming it DOES support @supports */\n}\n\n@supports not (--custom: property) {\n  /* Isolated CSS for browsers that DON'T support custom properties, assuming it DOES support @supports */\n}\n\n\nCredit\nThanks to Miriam Suzanne for co-authoring this with me!\n\n\n\n\n","html-content":"<div class=\"page\" id=\"readability-page-1\"><div>\n<main id=\"post-333595\">\n\n<article id=\"post-333595\">\n<div>\n<div>\n<div>\n<p>A custom property is most commonly thought of as a <strong>variable</strong> in CSS.</p>\n<pre data-line=\"\" rel=\"CSS\"><code>.card {\n  --spacing: 1.2rem;\n  padding: var(--spacing);\n  margin-bottom: var(--spacing);\n}</code></pre>\n<p>Above, <code>--spacing</code> is the custom property with <code>1.2rem</code> as the value and <code>var(--spacing)</code> is the variable in use. </p>\n<p>Perhaps the most valuable reason to use them: not repeating yourself (<abbr>DRY</abbr> code). In the example above, I can change the <strong>value</strong> <code>1.2rem</code> in <em>one</em> place and have it affect <em>two</em> things. This brings something programming languages do to CSS.</p>\n<p>There is a good bit to know about custom properties, so let’s get into it. </p>\n</div>\n<div>\n<h2 id=\"h-why-care-about-css-custom-properties\">Why care about CSS Custom Properties?</h2>\n<ol><li>They help DRY up your CSS. That is “Don’t Repeat Yourself.” Custom properties can make code easier to maintain because you can update one value and have it reflected in multiple places. Careful though, overdoing abstraction can make have the opposite effect and make code less understandable.</li><li>They are particularly helpful for things like creating <strong>color themes</strong> on a website.</li><li>They unlock interesting possibilities in CSS. In no small part because they cascade.</li><li>The fact that they can be updated in JavaScript opens up even more interesting possibilities.</li></ol>\n</div>\n</div>\n<div>\n<details>\n<summary>\n<h3>Table of contents</h3>\n</summary>\n<div><ul><li><a data-level=\"2\" href=\"#h-why-care-about-css-custom-properties\">Why care about CSS Custom Properties?</a><ul><li><a data-level=\"3\" href=\"#h-naming-custom-properties\">Naming custom properties</a><ul><li><a data-level=\"4\" href=\"#h-properties-as-properties\">Properties as properties</a></li></ul></li><li><a data-level=\"3\" href=\"#h-valid-values-for-custom-properties\">Valid values for custom properties</a></li><li><a data-level=\"3\" href=\"#h-breaking-up-values\">Breaking up values</a><ul><li><a data-level=\"4\" href=\"#h-splitting-colors\">Splitting colors</a></li><li><a data-level=\"4\" href=\"#h-shadows\">Shadows</a></li><li><a data-level=\"4\" href=\"#h-gradients\">Gradients</a></li><li><a data-level=\"4\" href=\"#h-comma-separated-values-like-backgrounds\">Comma-separated values (like backgrounds)</a></li><li><a data-level=\"4\" href=\"#h-grids\">Grids</a></li><li><a data-level=\"4\" href=\"#h-transforms\">Transforms</a></li><li><a data-level=\"4\" href=\"#h-concatenation-of-unit-types\">Concatenation of unit types</a></li></ul></li><li><a data-level=\"3\" href=\"#h-using-the-cascade\">Using the cascade</a><ul><li><a data-level=\"4\" href=\"#h-the-root-thing\">The :root thing</a></li></ul></li><li><a data-level=\"3\" href=\"#h-combining-with-important\">Combining with !important</a></li><li><a data-level=\"3\" href=\"#h-custom-property-fallbacks\">Custom property fallbacks</a></li><li><a data-level=\"3\" href=\"#h-using-calc-and-custom-properties\">Using calc() and custom properties</a><ul><li><a data-level=\"4\" href=\"#h-deferring-the-calc\">Deferring the calc()</a></li></ul></li><li><a data-level=\"3\" href=\"#h-property\">@property</a></li><li><a data-level=\"3\" href=\"#h-commas-in-values\">Commas in values</a></li><li><a data-level=\"3\" href=\"#h-advanced-usage\">Advanced usage</a><ul><li><a data-level=\"4\" href=\"#h-the-initial-and-whitespace-trick\">The initial and whitespace trick</a></li><li><a data-level=\"4\" href=\"#h-inline-styles\">Inline styles</a></li><li><a data-level=\"4\" href=\"#h-hovers-and-pseudos\">Hovers and pseudos</a></li></ul></li><li><a data-level=\"3\" href=\"#h-custom-properties-and-javascript\">Custom properties and JavaScript</a></li><li><a data-level=\"3\" href=\"#h-custom-properties-are-different-than-preprocessor-variables\">Custom properties are different than preprocessor variables</a><ul><li><a data-level=\"4\" href=\"#h-can-you-preprocess-custom-properties\">Can you preprocess custom properties?</a></li><li><a data-level=\"4\" href=\"#h-availiability\">Availiability</a></li></ul></li><li><a data-level=\"3\" href=\"#h-custom-properties-and-web-components-shadow-dom\">Custom properties and Web Components (Shadow DOM)</a></li><li><a data-level=\"3\" href=\"#h-browser-support\">Browser support</a><ul><li><a data-level=\"4\" href=\"#h-supports\">@supports</a></li></ul></li><li><a data-level=\"3\" href=\"#h-related-posts\">Related posts</a></li><li><a data-level=\"3\" href=\"#h-credit\">Credit</a></li></ul></li></ul></div>\n</details>\n\n</div>\n<h3 id=\"h-naming-custom-properties\">Naming custom properties</h3>\n<div>\n<div>\n<p>Custom properties <em>must</em> be within a selector and start with two dashes (<code>--</code>):</p>\n<pre data-line=\"\" rel=\"CSS\"><code>/* Nope, not within a selector */\n--foo: 1;\n\nbody {\n  /* No, 0 or 1 dash won't work */\n  foo: 1;\n  -foo: 1; \n\n  /* Yep! */\n  --foo: 1;\n\n  /* OK, but they're different properties */\n  --FOO: 1;\n  --Foo: 1;\n  \n  /* Totally fine */\n  --mainColor: red;\n  --main-color: red;\n\n  /* Special characters are a no */\n  <a data-cfemail=\"547979373b383b26143c3b3931\" href=\"https://css-tricks.com/cdn-cgi/l/email-protection\">[email&nbsp;protected]</a>: red;\n  --black&amp;blue: black;\n  --black^2: black;\n}</code></pre>\n<p>Best to stick with letters, numbers, and dashes while making sure the custom property is defined inside of a valid selector.</p>\n</div>\n<div>\n<h4 id=\"h-properties-as-properties\">Properties as properties</h4>\n<p>You can set the value of a custom property with another custom property:</p>\n<pre data-line=\"\" rel=\"CSS\"><code>html {\n  --red: #a24e34;\n  --green: #01f3e6;\n  --yellow: #f0e765;\n\n  --error: var(--red);\n  --errorBorder: 1px dashed var(--red);\n  --ok: var(--green);\n  --warning: var(--yellow);\n}</code></pre>\n<p>Some people like doing it this way because it allows the name of a custom property to be descriptive and then used in another property with a more functional name, again helping keep things <abbr>DRY</abbr>. It can even help make the functional names more readable and understandable.</p>\n</div>\n</div>\n<h3 id=\"h-valid-values-for-custom-properties\">Valid values for custom properties</h3>\n<div>\n<figure><img height=\"68\" width=\"61\" alt=\"\" src=\"https://css-tricks.com/wp-content/uploads/2021/04/lightbulb-icon-happy.svg\" loading=\"lazy\"></figure>\n<p>Custom properties are surprisingly tolerant when it comes to the values they accept. </p>\n</div>\n<p>Here are some basic examples that you’d expect to work, and do.</p>\n<pre data-line=\"\" rel=\"CSS\"><code>body {\n  --brand-color: #990000;\n  --transparent-black: rgba(0, 0, 0, 0.5);\n  \n  --spacing: 0.66rem;\n  --max-reading-length: 70ch;\n  --brandAngle: 22deg;\n\n  --visibility: hidden;\n  --my-name: \"Chris Coyier\";\n}</code></pre>\n<p>See that? They can be hex values, color functions, units of all kinds, and even strings of text.</p>\n\n<p>But custom properties don’t have to be complete values like that. Let’s look at how useful it can be to break up valid CSS values into parts we can shove into custom properties.</p>\n<h3 id=\"h-breaking-up-values\">Breaking up values</h3>\n<div>\n<figure><img height=\"68\" width=\"61\" alt=\"\" src=\"https://css-tricks.com/wp-content/uploads/2021/04/lightbulb-icon-happy.svg\" loading=\"lazy\"></figure>\n<p>You can use custom properties to break up multi-part values.</p>\n</div>\n<p>Let’s imagine you’re using a color function, say <code>rgba()</code>. Each color channel value in there can be its own custom property. That opens up a ton of possibilities, like changing the alpha value for a specific use case, or perhaps creating color themes.</p>\n<h4 id=\"h-splitting-colors\">Splitting colors</h4>\n<p>Take HSL color, for example. We can split it up into parts, then very easily adjust the parts where we want. Maybe we’re working with the background color of a button. We can update specific parts of its HSL makeup when the button is hovered, in focus, or disabled, without declaring <code>background</code> on any of those states at all.</p>\n<pre data-line=\"\" rel=\"CSS\"><code>button {\n  --h: 100;\n  --s: 50%;\n  --l: 50%;\n  --a: 1;\n\n  background: hsl(var(--h) var(--s) var(--l) / var(--a));\n}\nbutton:hover { /* Change the lightness on hover */\n  --l: 75%;\n}\nbutton:focus { /* Change the saturation on focus */\n  --s: 75%;\n}\nbutton[disabled] {  /* Make look disabled */\n  --s: 0%;\n  --a: 0.5;\n}</code></pre>\n<p>By breaking apart values like that, we can <a href=\"https://css-tricks.com/now-css-custom-properties-thing-value-parts-can-changed-individually/\">control <em>parts</em> of them</a> in a way we never could before. Just look at how we didn’t need to declare all of the HSL arguments to style the hover, focus and disabled state of a button. We simply overrode specific HSL values when we needed to. Pretty cool stuff!</p>\n<div>\n<div>\n<h4 id=\"h-shadows\">Shadows</h4>\n<p><code>box-shadow</code> doesn’t have a shorthand property for controlling the shadow’s spread on its own. But we could break out the <code>box-shadow</code> spread value and control it as a custom property (<a href=\"https://codepen.io/team/css-tricks/pen/PoWdVOw\">demo</a>).</p>\n<pre data-line=\"\" rel=\"CSS\"><code>button {\n  --spread: 5px;\n  box-shadow: 0 0 20px var(--spread) black;\n}\nbutton:hover {\n  --spread: 10px;\n}</code></pre>\n</div>\n<div>\n<h4 id=\"h-gradients\">Gradients</h4>\n<p>There is no such thing as a <code>background-gradient-angle</code> (or the like) shorthand for gradients. With custom properties, we can change just change that part as if there was such a thing.</p>\n<pre data-line=\"\" rel=\"CSS\"><code>body {\n  --angle: 180deg;\n  background: linear-gradient(var(--angle), red, blue);\n}\nbody.sideways {\n  --angle: 90deg;\n}</code></pre>\n</div>\n</div>\n<h4 id=\"h-comma-separated-values-like-backgrounds\">Comma-separated values (like backgrounds)</h4>\n<p>Any property that supports multiple comma-separated values might be a good candidate for splitting values too, since there is no such thing as targeting just one value of a comma-separated list and changing it alone.</p>\n<pre data-line=\"\" rel=\"CSS\"><code>/* Lots of backgrounds! */\nbackground-image:\n  url(./img/angles-top-left.svg),\n  url(./img/angles-top-right.svg),\n  url(./img/angles-bottom-right.svg),\n  url(./img/angles-bottom-left.svg),\n  url(./img/bonus-background.svg);</code></pre>\n<p>Say you wanted to remove <a href=\"https://css-tricks.com/managing-multiple-backgrounds-with-custom-properties/\">just one of many multiple backgrounds</a> at a media query. You could do that with custom properties like this, making it a trivial task to swap or override backgrounds.</p>\n<pre data-line=\"\" rel=\"CSS\"><code>body {\n  --bg1: url(./img/angles-top-left.svg);\n  --bg2: url(./img/angles-top-right.svg);\n  --bg3: url(./img/angles-bottom-right.svg);\n  --bg4: url(./img/angles-bottom-left.svg);\n  --bg5: url(./img/bonus-background.svg);\n  \n  background-image: var(--bg1), var(--bg2), var(--bg3), var(--bg4);\n}\n@media (min-width: 1500px) {\n  body {\n    background-image: var(--bg1), var(--bg2), var(--bg3), var(--bg4), var(--bg5);\n  }\n}</code></pre>\n<div>\n<div>\n<h4 id=\"h-grids\">Grids</h4>\n<p>We’re on a roll here, so we might as well do a few more examples. Like, hey, we can take the <code>grid-template-columns</code> property and abstract its values into custom properties to make a super flexible grid system:</p>\n<pre data-line=\"\" rel=\"CSS\"><code>.grid {\n  display: grid;\n  --edge: 10px;\n  grid-template-columns: var(--edge) 1fr var(--edge);\n}\n@media (min-width: 1000px) {\n  .grid {\n     --edge: 15%;\n   }\n}</code></pre>\n</div>\n<div>\n<h4 id=\"h-transforms\">Transforms</h4>\n<p>CSS will soon get <a href=\"https://drafts.csswg.org/css-transforms-2/#individual-transforms\">individual transforms</a> but we can get it sooner with custom properties. The idea is to apply all the transforms an element might get up front, then control them individually as needed:</p>\n<pre data-line=\"\" rel=\"CSS\"><code>button {\n  transform: var(--scale, scale(1)) var(--translate, translate(0));\n}\nbutton:active {\n  --translate: translate(0, 2px);\n}\nbutton:hover {\n  --scale: scale(0.9);\n}</code></pre>\n</div>\n</div>\n<h4 id=\"h-concatenation-of-unit-types\">Concatenation of unit types</h4>\n<p>There are times when combining parts of values doesn’t work quite how you might hope. For example, you can’t make <code>24px</code> by smashing <code>24</code> and <code>px</code> together. It can be done though, by <em>multiplying</em> the raw number by a number value with a unit.</p>\n<pre data-line=\"\" rel=\"CSS\"><code>body {\n  --value: 24;\n  --unit: px;\n  \n  /* Nope */\n  font-size: var(--value) + var(--unit);\n  \n  /* Yep */\n  font-size: calc(var(--value) * 1px);\n\n  /* Yep */\n  --pixel_converter: 1px;\n  font-size: calc(var(--value) * var(--pixel_converter));\n}</code></pre>\n\n<h3 id=\"h-using-the-cascade\">Using the cascade</h3>\n<div>\n<figure><img height=\"68\" width=\"61\" alt=\"\" src=\"https://css-tricks.com/wp-content/uploads/2021/04/lightbulb-icon-happy.svg\" loading=\"lazy\"></figure>\n<p>The fact that custom properties use <a href=\"https://css-tricks.com/the-c-in-css-the-cascade/\">the cascade</a> is one of the most useful things about them. </p>\n</div>\n<p>You’ve already seen it in action in many of the examples we’ve covered, but let’s put a point on it. Say we have a custom property set pretty “high up” (on the body), and then set again on a specific class. We use it on a specific component.</p>\n<pre data-line=\"\" rel=\"CSS\"><code>body {\n  --background: white;\n}\n.sidebar {\n  --background: gray;\n}\n.module {\n  background: var(--background);\n}</code></pre>\n<p>Then say we’ve got practical HTML like this:</p>\n<div>\n<div>\n<pre data-line=\"\" rel=\"HTML\"><code>&lt;body&gt; &lt;!-- --background: white --&gt;\n\n  &lt;main&gt;\n    &lt;div class=\"module\"&gt;\n      I will have a white background.\n    &lt;/div&gt;\n  &lt;main&gt;\n\n  &lt;aside class=\"sidebar\"&gt; &lt;!-- --background: gray --&gt;\n    &lt;div class=\"module\"&gt;\n      I will have a gray background.\n    &lt;/div&gt;\n  &lt;/aside&gt;\n\n&lt;/body&gt;</code></pre>\n</div>\n<div><figure><img data-recalc-dims=\"1\" sizes=\"(min-width: 735px) 864px, 96vw\" srcset=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/04/custom-property-cascade-inherit.jpg?w=1245&amp;ssl=1 1245w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/04/custom-property-cascade-inherit.jpg?resize=300%2C179&amp;ssl=1 300w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/04/custom-property-cascade-inherit.jpg?resize=1024%2C609&amp;ssl=1 1024w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/04/custom-property-cascade-inherit.jpg?resize=768%2C457&amp;ssl=1 768w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/04/custom-property-cascade-inherit.jpg?resize=1000%2C595&amp;ssl=1 1000w\" alt=\"Three CSS rulesets, one for a body, sidebar and module. the background custom property is defined as white on body and gray on sidebar. The module calls the custom property and shows an orange arrow pointing to the custom property defined in the sidebar since it is the nearest ancestor.\" src=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/04/custom-property-cascade-inherit.jpg?resize=1245%2C741&amp;ssl=1\" height=\"741\" width=\"1245\" loading=\"lazy\"><figcaption>For the second module, <code>.sidebar</code> is a closer ancestor than <code>body</code>, thus <code>--background</code> resolves to <code>gray</code> there, but white in other places.</figcaption></figure></div>\n</div>\n<p>The “module” in the sidebar has a gray background because custom properties (like many other CSS properties) <strong>inherit</strong> through the HTML structure. Each module takes the <code>--background</code> value from the nearest “ancestor” where it’s been defined in CSS.</p>\n<p>So, we have <em>one</em> CSS declaration but it’s doing different things in different contexts, thanks to the cascade. That’s just cool. </p>\n<p>This plays out in other ways:</p>\n<pre data-line=\"\" rel=\"CSS\"><code>button {\n  --foo: Default;\n}\nbutton:hover {\n  --foo: I win, when hovered;\n  /* This is a more specific selector, so re-setting \n     custom properties here will override those in `button` */\n}</code></pre>\n<p>Media queries don’t change specificity, but they often come <em>later</em> (or lower) in the CSS file than where the original selector sets a value, which also means a custom property will be overridden inside the media query:</p>\n<pre data-line=\"2,7\" rel=\"CSS\"><code>body {\n  --size: 16px;\n  font-size: var(--size);\n}\n@media (max-width: 600px) {\n  body {\n    --size: 14px;\n  } \n}</code></pre>\n<p><a href=\"https://css-tricks.com/a-complete-guide-to-css-media-queries/\">Media queries</a> aren’t only for screen sizes. They can be used for things like accessibility preferences. For example, <a href=\"https://css-tricks.com/a-complete-guide-to-dark-mode-on-the-web/\">dark mode</a>:</p>\n<pre data-line=\"\" rel=\"CSS\"><code>body {\n  --bg-color: white; \n  --text-color: black;\n\n  background-color: var(--bg-color);\n  color: var(--text-color);\n}\n\n/* If the user's preferred color scheme is dark */\n@media screen and (prefers-color-scheme: dark) {\n  body {\n    --bg-color: black;\n    --text-color: white;\n  }\n}</code></pre>\n<h4 id=\"h-the-root-thing\">The <code>:root</code> thing</h4>\n<p>You’ll often see custom properties being set “at the root.” Here’s what that means:</p>\n<pre data-line=\"1,2,3\" rel=\"CSS\"><code>:root {\n  --color: red;\n}\n\n/* ...is largely the same as writing: */\nhtml {\n  --color: red;\n}\n\n/* ...except :root has higher specificity, so remember that! */</code></pre>\n<p>There is no particularly compelling reason to define custom properties like that. It’s just a way of setting custom properties <em>as high up as they can go</em>. If you like that, that’s totally fine. I find it somehow more normal-feeling to apply them to the <code>html</code> or <code>body</code> selectors when setting properties I intend to make available globally, or everywhere.</p>\n<p>There is also no reason you <em>need</em> to set variables at this broad of a scope. It can be just as useful, and perhaps more readable and understandable, to set them right at the level you are going to use them (or fairly close in the DOM tree).</p>\n<pre data-line=\"\" rel=\"CSS\"><code>.module {\n  --module-spacing: 1rem;\n  --module-border-width: 2px;\n\n  border: var(--module-border-width) solid black;\n}\n\n.module + .module {\n  margin-top: var(--module-spacing);\n}</code></pre>\n<p>Note that setting a custom property on the module itself means that property will no longer inherit from an ancestor (unless we set the value to <code>inherit</code>). Like other inherited properties, there are sometimes reasons to specify them in place (at the global level), and other times we want to inherit them from context (at the component level). Both are useful. What’s cool about custom properties is that we can define them in one place, inherit them <em>behind the scenes<em> </em></em>and apply them <em><em>somewhere completely different</em></em>. We take control of the cascade!</p>\n\n<h3 id=\"h-combining-with-important\">Combining with <code>!important</code></h3>\n<div>\n<figure><img height=\"68\" width=\"61\" alt=\"\" src=\"https://css-tricks.com/wp-content/uploads/2021/04/lightbulb-icon-happy.svg\" loading=\"lazy\"></figure>\n<p>You can make an <code>!important</code> modifier within or outside of a variable.</p>\n</div>\n<pre data-line=\"\" rel=\"CSS\"><code>.override-red {\n  /* this works */\n  --color: red !important;  \n  color: var(--color);\n\n  /* this works, too */\n  --border: red;\n  border: 1px solid var(--border) !important;\n}</code></pre>\n<p>Applying <code>!important</code> to the <code>--color</code> variable, makes it difficult to override the value of the <code>--color</code> variable, but we can still ignore it by changing the <code>color</code> property. In the second example, our <code>--border</code> variable remains low-specificity (easy to override), but it’s hard to change how that value will be applied to the <code>border</code> itself.</p>\n<h3 id=\"h-custom-property-fallbacks\">Custom property fallbacks</h3>\n<div>\n<figure><img height=\"68\" width=\"61\" alt=\"\" src=\"https://css-tricks.com/wp-content/uploads/2021/04/lightbulb-icon-happy.svg\" loading=\"lazy\"></figure>\n<p>The <code>var()</code> function is what allows for fallback values in custom properties.</p>\n</div>\n<p>Here we’re setting a <code>scale()</code> transform function to a custom property, but there is a <strong>comma-separated</strong> second value of <code>1.2</code>. That <code>1.2</code> value will be used if <code>--scale</code> is not set.</p>\n<pre data-line=\"\" rel=\"CSS\"><code>.bigger {\n  transform: scale(var(--scale, 1.2));\n}</code></pre>\n<p>After the first comma, any additional commas are part of the fallback value. That allows us to create fallbacks with comma-separated values inside them. For example, we can have one variable fall back to an entire stack of fonts:</p>\n<pre data-line=\"\" rel=\"CSS\"><code>html {\n  font-family: var(--fonts, Helvetica, Arial, sans-serif);\n}</code></pre>\n<p>We can also provide a series of variable fallbacks (as many as we want), but we have to nest them for that to work:</p>\n<pre data-line=\"\" rel=\"CSS\"><code>.bigger {\n  transform: scale(var(--scale, var(--second-fallback, 1.2));\n}</code></pre>\n<p>If <code>--scale</code> is undefined, we try the <code>--second-fallback</code>. If that is also undefined, we finally fall back to <code>1.2</code>.</p>\n<h3 id=\"h-using-calc-and-custom-properties\">Using <code>calc()</code> and custom properties</h3>\n<div>\n<figure><img height=\"68\" width=\"61\" alt=\"\" src=\"https://css-tricks.com/wp-content/uploads/2021/04/lightbulb-icon-happy.svg\" loading=\"lazy\"></figure>\n<p>Even more power of custom properties is unlocked when we combine them with math!</p>\n</div>\n<p>This kind of thing is common:</p>\n<pre data-line=\"11\" rel=\"CSS\"><code>main {\n  --spacing: 2rem;\n}\n\n.module {\n  padding: var(--spacing);\n}\n\n.module.tight {\n  /* divide the amount of spacing in half */\n  padding: calc(var(--spacing) / 2)); \n}</code></pre>\n<p>We could also use that to calculate the hue of a complementary color:</p>\n<pre data-line=\"\" rel=\"CSS\"><code>html {\n  --brand-hue: 320deg;\n  --brand-color: hsl(var(--brand-hue), 50%, 50%);\n  --complement: hsl(calc(var(--brand-hue) + 180deg), 50%, 50%);\n}</code></pre>\n<p><code>calc()</code> can even be used with multiple custom properties:</p>\n<pre data-line=\"\" rel=\"CSS\"><code>.slider {\n  width: calc(var(--number-of-boxes) * var(--width-of-box));\n}</code></pre>\n<h4 id=\"h-deferring-the-calc\">Deferring the <code>calc()</code></h4>\n<p>It might look weird to see calculous-like math without a <code>calc()</code>:</p>\n<pre data-line=\"\" rel=\"CSS\"><code>body {\n  /* Valid, but the math isn't actually performed just yet ... */\n  --font-size: var(--base-font-size) * var(--modifier);\n\n  /* ... so this isn't going to work */\n  font-size: var(--font-size);\n}</code></pre>\n<p>The trick is that as long as you eventually put it in a <code>calc()</code> function, it works fine:</p>\n<pre data-line=\"\" rel=\"CSS\"><code>body {\n  --base-font-size: 16px;\n  --modifier: 2;\n  --font-size: var(--base-font-size) * var(--modifier);\n\n  /* The calc() is \"deferred\" down to here, which works */\n  font-size: calc(var(--font-size));\n}</code></pre>\n<p>This might be useful if you’re doing quite a bit of math on your variables, and the <code>calc()</code> wrapper becomes distracting or noisy in the code.</p>\n<h3 id=\"h-property\">@property</h3>\n<div>\n<figure><img height=\"68\" width=\"61\" alt=\"\" src=\"https://css-tricks.com/wp-content/uploads/2021/04/lightbulb-icon-happy.svg\" loading=\"lazy\"></figure>\n<p>The <code>@property</code> “at-rule” in CSS allows you to declare the type of a custom property, as well its as initial value and whether it inherits or not.</p>\n</div>\n<p>It’s sort of like you’re creating an actual CSS property and have the ability to define what it’s called, it’s syntax, how it interacts with the cascade, and its initial value.</p>\n<pre data-line=\"\" rel=\"CSS\"><code>@property --x {\n  syntax: '&lt;number&gt;';\n  inherits: false;\n  initial-value: 42;\n}</code></pre>\n<details>\n<summary>\nValid Types </summary>\n<ul><li><code>length</code></li><li><code>number</code></li><li><code>percentage</code></li><li><code>length-percentage</code></li><li><code>color</code></li><li><code>image</code></li><li><code>url</code></li><li><code>integer</code></li><li><code>angle</code></li><li><code>time</code></li><li><code>resolution</code></li><li><code>transform-list</code></li><li><code>transform-function</code></li><li><code>custom-ident</code>&nbsp;(a custom identifier string)</li></ul>\n</details>\n<p>This means that the browser knows what kind of value it is dealing with, rather than assuming everything is a string. That means you can animate things in ways you couldn’t otherwise.</p>\n<p>For example, say you have a star-shaped icon that you want to spin around with <code>@keyframes</code> and rotate with a <code>transform</code>. So you do this:</p>\n<pre data-line=\"2,9\" rel=\"CSS\"><code>.star {\n  --r: 0deg;\n  transform: rotate(var(--r));\n  animation: spin 1s linear infinite;\n}\n\n@keyframes spin {\n  100% {\n    --r: 360deg;\n  }\n}</code></pre>\n<p>That actually won’t work, as the browser doesn’t know that <code>0deg</code> and <code>360deg</code> are valid angle values. You have to define them as an <code>&lt;angle&gt;</code> type with <code>@property</code> for that to work.</p>\n<pre data-line=\"2\" rel=\"CSS\"><code>@property --r {\n  syntax: '&lt;angle&gt;';\n  initial-value: 0deg;\n  inherits: false;\n}\n\n.star {\n  --r: 0deg;\n  transform: rotate(var(--r));\n  animation: spin 1s linear infinite;\n}\n\n@keyframes spin {\n  100% {\n    --r: 360deg;\n  }\n}</code></pre>\n<details>\n<summary>\nDemo </summary>\n\n</details>\n\n<h3 id=\"h-commas-in-values\">Commas in values</h3>\n<p>This can be a smidge confusing. Maybe not so much this:</p>\n<pre data-line=\"\" rel=\"CSS\"><code>html {\n  --list: 1, 2, 3;\n}</code></pre>\n<p>But below, you’ll need a sharp eye to realize the fallback value is actually <code>1.2, 2</code>. The first comma separates the fallback, but all the rest is part of the value.</p>\n<pre data-line=\"\" rel=\"CSS\"><code>html {\n  transform: scale(var(--scale, 1.2, 2));\n}</code></pre>\n<p><a href=\"#h-custom-property-fallbacks\">Learn more about fallbacks above ⮑</a></p>\n<h3 id=\"h-advanced-usage\">Advanced usage</h3>\n<div>\n<figure><img height=\"68\" width=\"61\" alt=\"\" src=\"https://css-tricks.com/wp-content/uploads/2021/04/lightbulb-icon-happy.svg\" loading=\"lazy\"></figure>\n<p><a href=\"https://css-tricks.com/the-raven-technique-one-step-closer-to-container-queries/\">The Raven</a> is a technique that emulates container queries using math and custom properties. Be prepared, this goes from 0-100 in complexity right out of the gate!</p>\n</div>\n<details>\n<summary>\nDemo </summary>\n<p>Resize this demo to see a grid of inline-block elements change number of columns from 4 to 3 to 1.</p>\n\n</details>\n<p>Here’s a few more favorite examples that show off advanced usage of custom properties:</p>\n\n<h4 id=\"h-the-initial-and-whitespace-trick\">The <code>initial</code> and whitespace trick</h4>\n<p>Think of <code>@media</code> queries and how when <strong>one</strong> thing changes (e.g. the width of the page) you can control <strong>multiple</strong> things. That’s kind of the idea with this trick. You change <strong>one</strong> custom property and control <strong>multiple</strong> things. </p>\n<p>The trick is that the value of <code>initial</code> for a custom property will trigger a fallback, while an empty whitespace value will not. For the sake of explanation, it let’s define two globally-scoped custom properties, <code>ON</code> and <code>OFF</code>:</p>\n<pre data-line=\"\" rel=\"CSS\"><code>:root {\n  --ON: initial;\n  --OFF: ;\n}</code></pre>\n<p>Say we have a “dark” variation class which sets a number of different properties. The default is <code>--OFF</code>, but can be flipped to <code>--ON</code> whenever:</p>\n<pre data-line=\"\" rel=\"CSS\"><code>.module {\n  --dark: var(--OFF);\n}\n\n.dark { /* could be a media query or whatever */\n  --dark: var(--ON);\n}</code></pre>\n<p>Now you can use <code>--dark</code> to conditinally set values that apply only when you’ve flipped <code>--dark</code> to <code>--ON</code>. Demo:</p>\n\n<p><a href=\"https://lea.verou.me/2020/10/the-var-space-hack-to-toggle-multiple-values-with-one-custom-property/?\">Lea Verou has a great writeup</a> that covers all of this. </p>\n<h4 id=\"h-inline-styles\">Inline styles</h4>\n<p>It’s totally legit to set a custom property in HTML with an inline style.</p>\n<pre data-line=\"\" rel=\"HTML\"><code>&lt;div style=\"--color: red;\"&gt;&lt;/div&gt;</code></pre>\n<p>That will, like any inline style, have a very high level of specificity. </p>\n<p>This can be super useful for when the HTML might have access to some useful styling information that would be too weird/difficult to put into a static CSS file. A good example of that is maintaining the aspect ratio of an element:</p>\n<pre data-line=\"\" rel=\"HTML\"><code>&lt;div style=\"--aspect-ratio: 16 / 9;\"&gt;&lt;/div&gt;</code></pre>\n<p>Now I can set up some CSS to make a box of that exact size wherever I need to. <a href=\"https://css-tricks.com/aspect-ratio-boxes/#using-custom-properties\">The full writeup on that is here</a>, but here’s CSS that uses trickery like the <a href=\"https://daverupert.com/2012/04/uncle-daves-ol-padded-box/\">ol’ padded box</a> applied to a pseudo element which pushes the box to the desired size:</p>\n<pre data-line=\"\" rel=\"CSS\"><code>[style*=\"--aspect-ratio\"] &gt; :first-child {\n  width: 100%;\n}\n[style*=\"--aspect-ratio\"] &gt; img {  \n  height: auto;\n} \n@supports (--custom: property) {\n  [style*=\"--aspect-ratio\"] {\n    position: relative;\n  }\n  [style*=\"--aspect-ratio\"]::before {\n    content: \"\";\n    display: block;\n    padding-bottom: calc(100% / (var(--aspect-ratio)));\n  }  \n  [style*=\"--aspect-ratio\"] &gt; :first-child {\n    position: absolute;\n    top: 0;\n    left: 0;\n    height: 100%;\n  }  \n}</code></pre>\n<p>But hey, these days, we have a native <code><a href=\"https://css-tricks.com/almanac/properties/a/aspect-ratio/\">aspect-ratio</a></code> property in CSS, so setting that in the inline style might make more sense going forward.</p>\n<pre data-line=\"\" rel=\"HTML\"><code>&lt;div style=\"aspect-ratio: 16 / 9;\"&gt;&lt;/div&gt;</code></pre>\n<h4 id=\"h-hovers-and-pseudos\">Hovers and pseudos</h4>\n<p>There is no way to apply a <code>:hover</code> style (or other pseudo classes/elements) with inline styles. That is, <a href=\"https://css-tricks.com/want-to-write-a-hover-effect-with-inline-css-use-css-variables/\">unless we get tricky with custom properties</a>. Say we want custom hover colors on some boxes — we can pass that information in as a custom property:</p>\n<pre data-line=\"\" rel=\"HTML\"><code>&lt;div style=\"--hover-color: red;\"&gt;&lt;div&gt;\n&lt;div style=\"--hover-color: blue;\"&gt;&lt;div&gt;\n&lt;div style=\"--hover-color: yellow;\"&gt;&lt;div&gt;</code></pre>\n<p>Then use it in CSS which, of course, can style a link’s hover state:</p>\n<pre data-line=\"\" rel=\"CSS\"><code>div:hover {\n  background-color: var(--hover-color);\n}\n\n/* And use in other pseudos! */\ndiv:hover::after {\n  content: \"I am \" attr(style);\n  border-color: var(--hover-color);\n}</code></pre>\n<h3 id=\"h-custom-properties-and-javascript\">Custom properties and JavaScript</h3>\n<div>\n<figure><img height=\"68\" width=\"61\" alt=\"\" src=\"https://css-tricks.com/wp-content/uploads/2021/04/lightbulb-icon-happy.svg\" loading=\"lazy\"></figure>\n<p>JavaScript can set the value of a custom property.</p>\n</div>\n<pre data-line=\"\" rel=\"JavaScript\"><code>element.style.setProperty('--x', value);</code></pre>\n<p>Here’s an example of a red square that is positioned with custom properties, and JavaScript updates those custom property values with the mouse position:</p>\n\n<p>Typically you think of JavaScript passing values to CSS to use, which is probably 99% of usage here, but note that you can pass things from CSS to JavaScript as well. <a href=\"#valid-values-for-custom-properties\">As we’ve seen</a>, the value of a custom property can be fairly permissive. That means you could pass it a logical statement. For example:</p>\n<pre data-line=\"\" rel=\"CSS\"><code>html {\n  --logic: if (x &gt; 5) document.body.style.background = \"blue\";\n}</code></pre>\n<p>Then grab that value and execute it in JavaScript:</p>\n<pre data-line=\"\" rel=\"JavaScript\"><code>const x = 10;\n\nconst logic = getComputedStyle(document.documentElement).getPropertyValue(\n  \"--logic\"\n);\n\neval(logic);</code></pre>\n<h3 id=\"h-custom-properties-are-different-than-preprocessor-variables\">Custom properties are different than preprocessor variables</h3>\n<div>\n<figure><img height=\"68\" width=\"61\" alt=\"\" src=\"https://css-tricks.com/wp-content/uploads/2021/04/lightbulb-icon-happy.svg\" loading=\"lazy\"></figure>\n<p>Say you’re already using Sass, Less, or Stylus. All those CSS preprocessors offer variables and it’s one of the main reasons to have them as part of your build process.</p>\n</div>\n<pre data-line=\"\" rel=\"SCSS\"><code>// Variable usage in Sass (SCSS)\n$brandColor: red;\n\n.marketing {\n  color: $brandColor;\n}</code></pre>\n<p>So, <strong>do you even need to bother with native CSS custom properties then?</strong> Yes, you should. Here’s why in a nutshell:</p>\n<ul><li><strong>Native CSS custom properties are more powerful then preprocessor variables.</strong> Their integration with the <strong>cascade</strong> in the DOM is something that preprocessor variables will never be able to do.</li><li><strong>Native CSS custom properties are dynamic.</strong> When they change (perhaps via JavaScript, or with a media query), the browser repaints what it needs to. Preprocessor variables resolve to a value when they’re compiled and stay at that value.</li><li><strong>Going with a native feature is good for the longevity of your code.</strong> You don’t need to preprocess native CSS.</li></ul>\n<p>I cover this in much more detail in the article <a href=\"https://css-tricks.com/difference-between-types-of-css-variables/\">“What is the difference between CSS variables and preprocessor&nbsp;variables?”</a></p>\n<p>To be totally fair, there are little things that preprocessor variables can do that are hard or impossible with custom properties. Say you wanted to strip the units off a value for example. <a href=\"https://css-tricks.com/snippets/sass/strip-unit-function/\">You can do that in Sass</a> but you’ll have a much harder time with custom properties in CSS alone.</p>\n<h4 id=\"h-can-you-preprocess-custom-properties\">Can you preprocess custom properties?</h4>\n<p>Kinda. You can do this, with Sass just to pick one popular preprocessor:</p>\n<pre data-line=\"\" rel=\"SCSS\"><code>$brandColor: red;\nbody {\n  --brandColor: $brandColor;\n}</code></pre>\n<p>All that’s doing is moving a Sass variable to a custom property. That could be useful sometimes, but not terribly. Sass will just make <code>--brandColor: red;</code> there, not process the custom property away. </p>\n<p>If a browser doesn’t support custom properties, that’s that. You can’t <em>force</em> a browser to do what custom properties do by CSS syntax transformations alone. There might be some kind of JavaScript polyfill that parses your CSS and replicates it, but I really don’t suggest that. </p>\n<p>The <a href=\"https://github.com/postcss/postcss-custom-properties\">PostCSS Custom Properties</a> plugin, though, does do CSS syntax transforms to help. What it does is figure out the value to the best of it’s ability, and outputs that along with the custom property. So like:</p>\n<pre data-line=\"\" rel=\"CSS\"><code>:root {\n  --brandColor: red;\n}\nbody {\n  color: var(--brandColor);\n}</code></pre>\n<p>Will output like this:</p>\n<pre data-line=\"\" rel=\"CSS\"><code>:root {\n  --brandColor: red;\n}\nbody {\n  color: red;\n  color: var(--brandColor);\n}</code></pre>\n<p>That means you get a value that hopefully doesn’t seem broken in browsers that lack custom property support, but does not support any of the fancy things you can do with custom properties and will not even attempt to try. I’m a bit dubious about how useful that is, but I think this is about the best you can do and I like the spirit of attempting to not break things in older browsers <em>or</em> newer browsers.</p>\n<h4 id=\"h-availiability\">Availiability</h4>\n<p>Another thing that is worth noting about the difference between is that with a CSS preprocessor, the variables are available <em>only</em> as you’re processing. Something like <code>$brandColor</code> is meaningless in your HTML or JavaScript. But when you have custom properties in use, you can set inline styles that use those custom properties and they will work. Or you can use JavaScript to figure out their current values (in context), if needed.</p>\n<p>Aside from some somewhat esoteric features of preprocessor variables (e.g. some math possibilities), custom properties are more capable and useful. </p>\n<h3 id=\"h-custom-properties-and-web-components-shadow-dom\">Custom properties and Web Components (Shadow DOM)</h3>\n<div>\n<figure><img height=\"68\" width=\"61\" alt=\"\" src=\"https://css-tricks.com/wp-content/uploads/2021/04/lightbulb-icon-happy.svg\" loading=\"lazy\"></figure>\n<p>One of the most common and practical ways to style of Web Components (e.g. a <code>&lt;custom-component&gt;</code> with shadow DOM) is by using custom properties as styling hooks. </p>\n</div>\n<p>The main point of the shadow DOM is that it doesn’t “leak” styles in or out of it, offering style isolation in a way that nothing else offers, short of an <code>&lt;iframe&gt;</code>. Styles do still <em>cascade</em> their way inside, I just can’t select my way inside. This means custom properties will slide right in there.</p>\n<p>Here’s an example:</p>\n\n<p>Another common occurrence of the shadow DOM is with SVG and the <code>&lt;use&gt;</code> element. </p>\n\n<p>Video: <a href=\"https://css-tricks.com/video-screencasts/190-css-custom-properties-penetrate-the-shadow-dom/\">“CSS Custom Properties Penetrate the Shadow DOM”</a></p>\n<h3 id=\"h-browser-support\">Browser support</h3>\n<div><div><h4>Desktop</h4><table><thead><tr><th><span>Chrome</span></th><th><span>Firefox</span></th><th><span>IE</span></th><th><span>Edge</span></th><th><span>Safari</span></th></tr></thead><tbody><tr><td title=\"Chrome -\"><span>49</span></td><td title=\"Firefox -\"><span>31</span></td><td title=\"IE -\"><span>No</span></td><td title=\"Edge -\"><span>16</span></td><td title=\"Safari -\"><span>10</span></td></tr></tbody></table></div><div><h4>Mobile / Tablet</h4><table><thead><tr><th><span>Android Chrome</span></th><th><span>Android Firefox</span></th><th><span>Android</span></th><th><span>iOS Safari</span></th></tr></thead><tbody><tr><td title=\"Android Chrome -\"><span>90</span></td><td title=\"Android Firefox -\"><span>87</span></td><td title=\"Android -\"><span>90</span></td><td title=\"iOS Safari -\"><span>10.0-10.2</span></td></tr></tbody></table></div></div>\n<p>You can <a href=\"#h-can-you-preprocess-custom-properties\">preprocess for deeper browser support</a>, with heavy limitations.</p>\n<h4 id=\"h-supports\">@supports</h4>\n<p>If you would like to write conditional CSS for when a browser supports custom properties or not:</p>\n<pre data-line=\"\" rel=\"CSS\"><code>@supports (--custom: property) {\n  /* Isolated CSS for browsers that DOES support custom properties, assuming it DOES support @supports */\n}\n\n@supports not (--custom: property) {\n  /* Isolated CSS for browsers that DON'T support custom properties, assuming it DOES support @supports */\n}</code></pre>\n\n\n<h3 id=\"h-credit\">Credit</h3>\n<p>Thanks to Miriam Suzanne for co-authoring this with me!</p>\n</div>\n</article>\n</main>\n\n</div></div>"}